#include <iostream>
#include <random>
#include <ctime>
#include <string>
#include <time.h> 
#include <unistd.h>
#include <vector>

using namespace std;
unsigned const int x = 10 ;
unsigned const int y = 10 ;
//---------------------------------------------------------------------------------------------//
string algorithmLogfile="",algorithmHelpingLogfile="",generalLogfile="";
int leftWall,rightWall,forwardWall,backWall;
int buff;
int xrobot=5,yrobot=5,robotTurnPosition=1;
int fild [x][y][6]={0};
vector<int> memoryX(1,0);
vector<int> memoryY(1,0);
int myCordX=0,myCordY=0;
int simulatedCordX=0,simulatedCordY=0;
int counterMem=0;
int checkLeftPosition,checkRightPosition,checkForwardPosition;
//---------------------------------------------------------------------------------------------//
int memorySearchElement(int xC,int yC){
	int count=0;
	for(int i=0;i<counterMem;i++)
	{
		if(memoryX[i]==xC&&memoryY[i]==yC){
			count++;
		}
	}
	return count;
}

void memoryAddCordinate(int xC,int yC){
	counterMem++;
	memoryX.push_back(xC);
	memoryY.push_back(yC);
}

void generate(){
	for(int xi=0;xi<x;xi++){
		for(int yi=0;yi<y;yi++){
			buff=rand()%2;
			fild[xi][yi][rand()%4+1]=1;
		}
	}
	 for(int xi=0;xi<x;xi++){
	 	for(int yi=0;yi<y;yi++){
			for(int n=1;n<5;n++){
				if(n==1&&yi>0){
					fild[xi][yi-1][3]=fild[xi][yi][1];
				}
				if(n==2&&xi<x-1){
					fild[xi+1][yi][4]=fild[xi][yi][2];
				}
				if(n==3&&yi<y-1){
					fild[xi][yi+1][1]=fild[xi][yi][3];
				}
				if(n==4&&xi>0){
					fild[xi-1][yi][2]=fild[xi][yi][4];
				}
			}
		}		
	}
	for(int ix=0;ix<x;ix++){
		fild[ix][0][1]=1;
	}
	for(int ix=0;ix<x;ix++){
		fild[ix][y-1][3]=1;
	}
	for(int yx=0;yx<y;yx++){
		fild[0][yx][4]=1;
	}
	for(int yx=0;yx<y;yx++){
		fild[x-1][yx][2]=1;
	}
}

void draw(){
	system("clear");	
	for(int yi=0;yi<y;yi++){
		for(int xi=0;xi<x;xi++){
			if(fild[xi][yi][4]==1){
				cout<<"\x1B[0;34;40m"<<1<<"\x1B[0;0;40m";
			}
			else{
				if(fild[xi][yi][1]){
					cout<<"\x1B[0;34;40m"<<1<<"\x1B[0;0;40m";
				}
				else{
					cout<<fild[xi][yi][1];
				}
			}
			if(fild[xi][yi][1]){
					cout<<"\x1B[0;34;40m"<<1<<"\x1B[0;0;40m";
				}
				else{
					cout<<fild[xi][yi][1];
				}
			if(fild[xi][yi][2]==1){
				cout<<"\x1B[0;34;40m"<<1<<"\x1B[0;0;40m";
			}
			else{
				if(fild[xi][yi][1]){
					cout<<"\x1B[0;34;40m"<<1<<"\x1B[0;0;40m";
				}
				else{
					cout<<fild[xi][yi][1];
				}
			}
		}
		cout<<endl;
		for(int xi=0;xi<x;xi++){
			if(fild[xi][yi][4]){
					cout<<"\x1B[0;34;40m"<<1<<"\x1B[0;0;40m";
				}
				else{
					cout<<fild[xi][yi][4];
				}
			if(fild[xi][yi][0]==0){
				cout<<"\x1B[0;31;40m"<<fild[xi][yi][0]<<"\x1B[0;0;40m";
			}
			else if(fild[xi][yi][0]==1){
				cout<<"\x1B[0;33;40m"<<fild[xi][yi][0]<<"\x1B[0;0;40m";
			}
			else{
				cout<<"\x1B[1;32;40m"<<fild[xi][yi][0]<<"\x1B[0;0;40m";
			}
			if(fild[xi][yi][2]){
				cout<<"\x1B[0;34;40m"<<1<<"\x1B[0;0;40m";
			}
			else{
				cout<<fild[xi][yi][2];
			}
		}
		cout<<endl;
		for(int xi=0;xi<x;xi++){
			if(fild[xi][yi][4]==1){
				cout<<"\x1B[0;34;40m"<<1<<"\x1B[0;0;40m";
			}
			else{
				if(fild[xi][yi][3]){
					cout<<"\x1B[0;34;40m"<<1<<"\x1B[0;0;40m";
				}
				else{
					cout<<fild[xi][yi][3];
				}
			}
			if(fild[xi][yi][3]){
				cout<<"\x1B[0;34;40m"<<1<<"\x1B[0;0;40m";
			}
			else{
				cout<<fild[xi][yi][3];
			}
			if(fild[xi][yi][2]==1){
				cout<<"\x1B[0;34;40m"<<1<<"\x1B[0;0;40m";
			}
			else{
				if(fild[xi][yi][3]){
					cout<<"\x1B[0;34;40m"<<1<<"\x1B[0;0;40m";
				}
				else{
					cout<<fild[xi][yi][3];
				}
			}
		}
		if(yi==0){
			cout<<"forwardWall: "<<forwardWall;	
		}
		if(yi==1){
			cout<<"rightWall: "<<rightWall;	
		}
		if(yi==2){
			cout<<"leftWall: "<<leftWall;	
		}
		if(yi==3){
			cout<<"backWall: "<<backWall;	
		}
		if(yi==4){
			cout<<"angel: ";
			if(robotTurnPosition==1){
				cout<<"↑";
			}
			if(robotTurnPosition==2){
				cout<<"→";
			}
			if(robotTurnPosition==3){
				cout<<"↓";
			}
			if(robotTurnPosition==4){
				cout<<"←";
			}	
		}
		cout<<endl;
	}
		}
void turnLeft(){
	algorithmLogfile+='l';
	generalLogfile+="Left ";
	robotTurnPosition--;
	if(robotTurnPosition==0){
		robotTurnPosition=4;
	}
}
void turnRight(){
	algorithmLogfile+='r';
	generalLogfile+="Right ";
	robotTurnPosition++;
	if(robotTurnPosition==5){
		robotTurnPosition=1;
	}
}
void issueTurnLeft(){
	robotTurnPosition--;
	if(robotTurnPosition==0){
		robotTurnPosition=4;
	}
}
void issueTurnRight(){
	robotTurnPosition++;
	if(robotTurnPosition==5){
		robotTurnPosition=1;
	}
}
void searchWallAround(){
	forwardWall=fild[xrobot][yrobot][robotTurnPosition];
	if(robotTurnPosition==1){
		leftWall=fild[xrobot][yrobot][4];
	}
	else{
		leftWall=fild[xrobot][yrobot][robotTurnPosition-1];
	}
	if(robotTurnPosition==4){
		rightWall=fild[xrobot][yrobot][1];
	}
	else{
		rightWall=fild[xrobot][yrobot][robotTurnPosition+1];
	}
	if(robotTurnPosition==1||robotTurnPosition==2){
		backWall=fild[xrobot][yrobot][robotTurnPosition+2];
	}
	else{
		backWall=fild[xrobot][yrobot][robotTurnPosition-2];	
	}
}
void simulatedCord(int angel){
	if(angel==1){
		issueTurnRight();
	}
	if(angel==-1){
		issueTurnLeft();
	}
	if(robotTurnPosition==1){
		simulatedCordY=myCordY-1;
		simulatedCordX=myCordX;
		}
	if(robotTurnPosition==2){
		simulatedCordX=myCordX+1;
		simulatedCordY=myCordY;
	}
	if(robotTurnPosition==3){
		simulatedCordY=myCordY+1;
		simulatedCordX=myCordX;
	}
	if(robotTurnPosition==4){
		simulatedCordX=myCordX-1;
		simulatedCordY=myCordY;
	}
	if(angel==1){
		issueTurnLeft();
	}
	if(angel==-1){
		issueTurnRight();
	}
}
void  goForward(){
	if(fild[xrobot][yrobot][robotTurnPosition]==0){
		algorithmLogfile+='g';
		generalLogfile+="Forward ";
		fild[xrobot][yrobot][0]=1;

		if(robotTurnPosition==1){
			yrobot-=1;
			myCordY-=1;
		}
		if(robotTurnPosition==2){
			xrobot+=1;
			myCordX+=1;
		}
		if(robotTurnPosition==3){
			yrobot+=1;
			myCordY+=1;
		}
		if(robotTurnPosition==4){
			xrobot-=1;
			myCordX-=1;
		}
		fild[xrobot][yrobot][0]=2;
	}
	else{
		algorithmLogfile+='c';
	}
	memoryAddCordinate(myCordX,myCordY);
	usleep(250000);
	draw();
}
void sensControll(){
		char command;
		cin>>command;
		if(command=='g'){
			goForward();
		}
		if(command=='l'){
			turnLeft();
			draw();
		}
		if(command=='r'){
			turnRight();
			draw();
		}
		cout<<endl;
		cout<<"myCord "<<myCordX<<" : "<<myCordY<<endl;
simulatedCord(0);
		cout<<"cordStr "<<simulatedCordX<<" : "<<simulatedCordY;
}
void randomeGo(){
	buff=rand()%100;
	if(buff<34){
		if(forwardWall==0){
			goForward();
		}
		else if(leftWall==0){
			turnLeft();
			goForward();
		}	
		else if(rightWall==0){
			turnRight();
			goForward();
		}
		else{
			turnRight();
		}
	}
	else if(buff>66){
		if(leftWall==0){
			turnLeft();
			goForward();
		}	
		else if(rightWall==0){
			turnRight();
			goForward();
		}
		else if(forwardWall==0){
			goForward();
		}
		else{
			turnRight();
		}
	}
	else{	
		if(rightWall==0){
			turnRight();
			goForward();
		}
		else if(forwardWall==0){
			goForward();
		}
		else if(leftWall==0){
			turnLeft();
			goForward();
		}
		else{
			turnRight();
		}		
	}
}
void algorithm(){
	searchWallAround();
	memoryX[0]=0;
	memoryY[0]=0;
	counterMem=1;
	for(int i =0 ;i>-1;i++){
		checkLeftPosition=0;
		checkRightPosition=0;
		checkForwardPosition=0;
		searchWallAround();
simulatedCord(-1);
		checkLeftPosition=memorySearchElement(simulatedCordX,simulatedCordY);
simulatedCord(0);
		checkForwardPosition=memorySearchElement(simulatedCordX,simulatedCordY);
simulatedCord(1);
		checkRightPosition=memorySearchElement(simulatedCordX,simulatedCordY);
		cout<<endl<<"radar"<<checkLeftPosition<<" "<<checkForwardPosition<<" "<<checkRightPosition<<" "<<endl;
		if(forwardWall==0&&checkForwardPosition==0){
			goForward();
		}
		else if(leftWall==0&&checkLeftPosition==0&&rightWall==0&&checkRightPosition==0){
			buff=rand()%100+1;
			if(buff>50){
				turnLeft();
				goForward();
			}
			else{
				turnRight();
				goForward();
			}
		}
		else if(leftWall==0&&checkLeftPosition==0){
			turnLeft();
			goForward();
		}	
		else if(rightWall==0&&checkRightPosition==0){
			turnRight();
			goForward();
		}
		else if(forwardWall==0&&checkForwardPosition==0){
			goForward();
		}
		else{
			algorithmHelpingLogfile=algorithmLogfile;
			turnLeft();
			turnLeft();
			algorithmLogfile.pop_back();
			algorithmLogfile.pop_back();
			bool flag=1;
			while(flag){
				if(algorithmLogfile.length()==0){
					flag=0;
				}
				else if(algorithmLogfile[algorithmLogfile.length()-1]=='g'){
					goForward();
					algorithmLogfile.pop_back();
				}
				else if(algorithmLogfile[algorithmLogfile.length()-1]=='r'){
					turnLeft();
					algorithmLogfile.pop_back();
				}
				else if(algorithmLogfile[algorithmLogfile.length()-1]=='l'){
					turnRight();
					algorithmLogfile.pop_back();
				}
				searchWallAround();
				checkLeftPosition=0;
				checkRightPosition=0;
				checkForwardPosition=0;
				algorithmLogfile.pop_back();
				algorithmHelpingLogfile.pop_back();
		simulatedCord(-1);
				checkLeftPosition=memorySearchElement(simulatedCordX,simulatedCordY);
		simulatedCord(0);
				checkForwardPosition=memorySearchElement(simulatedCordX,simulatedCordY);
		simulatedCord(1);
				checkRightPosition=memorySearchElement(simulatedCordX,simulatedCordY);
				if(leftWall==0&&checkLeftPosition==0||rightWall==0&&checkRightPosition==0||forwardWall==0&&checkForwardPosition==0){
					flag=0;
					turnRight();
					turnRight();
					algorithmLogfile.pop_back();
					algorithmLogfile.pop_back();
					algorithmLogfile=algorithmHelpingLogfile;
				}
			}
		}
		// else if(leftWall==0){
		// 	turnLeft();
		// 	goForward();
		// }	
		// else if(rightWall==0){
		// 	turnRight();
		// 	goForward();
		// }
		// else if(forwardWall==0){
		// 	goForward();
		// }
		// else{
		// 	randomeGo();
		
		// }
		cout<<endl;
		cout<<"myCord "<<myCordX<<" : "<<myCordY<<endl;
//
	}
	draw();
}
void test(){
	fild[yrobot][xrobot][0]=2;
	usleep(1000000);
	draw();
}
int main()
{
	cout<<"\x1B[0;0;40m";
	srand( time(0) );
	xrobot=rand()%x;
	yrobot=rand()%y;
	generate();
	//test();
	algorithm();
	//cout<<rand()%2<<"\x1B[0;2;40m"<<endl<<algorithmLogfile<<endl;
    return 0;
}
